public abstract class Enemy : MonoBehaviour
{
    [Header("血量系统")]
    public float maxHealth = 100f;
    public float currentHealth;

    [Header("状态持续时间")]
    public float idleTime = 3f;
    public float hurtEffectDuration = 0.2f;

    [Header("移动追击系统")]
    [Range(0, 100)]
    public float moveSpeed = 2f;
    [Range(0, 100)]
    public float chaseSpeed = 4f;

    [Header("检测范围")]
    public float chaseRange = 5f;
    public float attackRange = 1.5f;

    [Header("状态")]
    public bool isDead;
    public bool isfaceingRight;
    public bool canMove = true;

    [Header("目标")]
    public GameObject Goal;

    [Header("动画系统")]
    public Animator animator;

    [Header("巡逻系统")]
    public float patrolTime = 5f;
    public float patrolRange = 8f;
    private Vector2 patrolStartPosition;

    // 状态机相关
    private EnemyState currentState;
    private Dictionary<string, EnemyState> stateCache = new Dictionary<string, EnemyState>();

    // 属性访问器
    public EnemyState CurrentState => currentState;
    public Vector2 PatrolStartPosition => patrolStartPosition;

    public virtual void Start()
    {
        currentHealth = maxHealth;
        isfaceingRight = false;
        patrolStartPosition = transform.position; // 初始化巡逻起点

        // 初始化状态机，从待机状态开始
        ChangeState(new IdleState(this));
    }

    public virtual void Update()
    {
        // 更新当前状态
        if (currentState != null)
        {
            currentState.Update();
        }
    }

    public virtual void FixedUpdate()
    {
        // 更新物理相关逻辑
        if (currentState != null)
        {
            currentState.FixedUpdate();
        }
    }

    // 状态机核心方法
    public void ChangeState(EnemyState newState)
    {
        if (isDead) return; // 死亡后不再切换状态

        // 退出当前状态
        if (currentState != null)
        {
            currentState.Exit();
        }

        // 切换到新状态
        currentState = newState;
        currentState.Enter();

        // 缓存状态以便复用
        string stateName = newState.GetType().Name;
        if (!stateCache.ContainsKey(stateName))
        {
            stateCache[stateName] = newState;
        }
    }

    // 获取缓存的状态实例
    public T GetCachedState<T>() where T : EnemyState
    {
        string stateName = typeof(T).Name;
        if (stateCache.ContainsKey(stateName))
        {
            return stateCache[stateName] as T;
        }
        return null;
    }

    // 检测方法
    public bool IsGoalInChaseRange()
    {
        if (Goal == null) return false;
        float distance = Vector2.Distance(transform.position, Goal.transform.position);
        return distance <= chaseRange;
    }

    public bool IsGoalInAttackRange()
    {
        if (Goal == null) return false;
        float distance = Vector2.Distance(transform.position, Goal.transform.position);
        return distance <= attackRange;
    }

    public bool IsTooFarFromPatrolStart(Vector2 patrolStartPosition)
    {
        float distance = Vector2.Distance(transform.position, patrolStartPosition);
        return distance > patrolRange;
    }

    // 翻转逻辑
    public void UpdatePatrolStartPosition()
    {
        patrolStartPosition = transform.position;
        Debug.Log($"更新巡逻起始位置: {patrolStartPosition}");
    }

    // 受伤方法
    public virtual void TakeDamage(float damage)
    {
        if (isDead) return;

        // 通过当前状态处理受伤
        if (currentState != null)
        {
            currentState.OnHurt(damage);
        }
        else
        {
            // 如果没有当前状态，直接扣血
            currentHealth -= damage;
            if (currentHealth <= 0)
            {
                ChangeState(new DeadState(this));
            }
            else
            {
                ChangeState(new HurtState(this));
            }
        }
    }

    // 攻击方法 - 子类需要实现具体的攻击逻辑
    public virtual void EnemyAttack()
    {
        // 基础攻击逻辑，子类可以重写
        Debug.Log($"{gameObject.name} 执行攻击");

        // 这里可以添加具体的攻击逻辑，如伤害检测等
        // 例如：检查攻击范围内是否有玩家并造成伤害
    }

    // 动画事件回调
    public void OnAttackAnimationEnd()
    {
        // 动画结束时可以调用此方法
        // 例如：在攻击动画结束后可以触发状态切换
    }

    // 可视化调试
    private void OnDrawGizmosSelected()
    {
        // 绘制追击范围
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireSphere(transform.position, chaseRange);

        // 绘制攻击范围
        Gizmos.color = Color.red;
        Gizmos.DrawWireSphere(transform.position, attackRange);

        // 绘制巡逻范围（如果已知起始点）
        Gizmos.color = Color.blue;
        Gizmos.DrawWireSphere(transform.position, patrolRange);
    }

    // 调试信息
    private void OnGUI()
    {
        if (currentState != null)
        {
            GUI.Label(new Rect(10, 10, 200, 30), $"当前状态: {currentState.GetType().Name}");
            GUI.Label(new Rect(10, 40, 200, 30), $"血量: {currentHealth}/{maxHealth}");
        }
    }

}
